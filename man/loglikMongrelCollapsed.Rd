% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{loglikMongrelCollapsed}
\alias{loglikMongrelCollapsed}
\alias{gradMongrelCollapsed}
\alias{hessMongrelCollapsed}
\title{Calculations for the Collapsed Mongrel Model}
\usage{
loglikMongrelCollapsed(Y, upsilon, ThetaX, K, A, eta)

gradMongrelCollapsed(Y, upsilon, ThetaX, K, A, eta)

hessMongrelCollapsed(Y, upsilon, ThetaX, K, A, eta)
}
\arguments{
\item{Y}{D x N matrix of counts}

\item{upsilon}{(must be > D)}

\item{ThetaX}{D-1 x N matrix formed by Theta*X (Theta is Prior mean
for regression coefficients)}

\item{K}{D-1 x D-1 precision matrix (inverse of Xi)}

\item{A}{N x N precision matrix given by (I_N + X\emph{Gamma}X')^{-1}]}

\item{eta}{matrix (D-1)xN of parameter values at which to calculate quantities}
}
\value{
see below
\itemize{
\item loglikMongrelCollapsed - double
\item gradMongrelCollapsed - vector
\item hessMongrelCollapsed- matrix
}
}
\description{
Functions providing access to the Log Likelihood, Gradient, and Hessian
of the collapsed mongrel model. Note: These are convenience functions
but are not as optimized as direct coding of the MongrelCollapsed
C++ class due to a lack of Memoization. By contrast function optimMongrelCollapsed
is much more optimized and massively cuts down on repeated calculations.
A more efficient Rcpp module based implementation of these functions
may following if the future. For model details see \code{\link{optimMongrelCollapsed}}
documentation
}
\examples{
D <- 10
Q <- 2
N <- 30

# Simulate Data
Sigma <- diag(sample(1:8, D-1, replace=TRUE))
Sigma[2, 3] <- Sigma[3,2] <- -1
Gamma <- diag(sqrt(rnorm(Q)^2))
Theta <- matrix(0, D-1, Q)
Phi <-  Theta + t(chol(Sigma))\%*\%matrix(rnorm(Q*(D-1)), nrow=D-1)\%*\%chol(Gamma)
X <- matrix(rnorm(N*(Q-1)), Q-1, N)
X <- rbind(1, X)
Eta <- Phi\%*\%X + t(chol(Sigma))\%*\%matrix(rnorm(N*(D-1)), nrow=D-1)
Pi <- t(driver::alrInv(t(Eta)))
Y <- matrix(0, D, N)
for (i in 1:N) Y[,i] <- rmultinom(1, sample(5000:10000), prob = Pi[,i])

# Priors
upsilon <- D+10
Xi <- Sigma*(upsilon-D-2)

# Precompute
K <- solve(Xi)
A <- solve(diag(N)+ t(X)\%*\%Gamma\%*\%X)
ThetaX <- Theta\%*\%X


loglikMongrelCollapsed(Y, upsilon, ThetaX, K, A, Eta)
gradMongrelCollapsed(Y, upsilon, ThetaX, K, A, Eta)
hessMongrelCollapsed(Y, upsilon, ThetaX, K, A, Eta)
}
